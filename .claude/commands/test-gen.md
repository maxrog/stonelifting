# Test Generator

Generate comprehensive unit and integration tests for Swift services and ViewModels following CLAUDE.md standards.

## Usage

Provide the file path or class name you want to generate tests for:
- **File path**: `iOS/StoneLifting/StoneLifting/Services/AuthService.swift`
- **Class name**: `AuthService`
- **Multiple files**: List multiple paths/names

## Instructions

### 1. Analyze the Target File

Read and understand:
- [ ] Public API (all public/internal methods)
- [ ] Dependencies (services, APIs, external systems)
- [ ] State management (observable properties)
- [ ] Error handling (custom error types)
- [ ] Async operations and concurrency patterns
- [ ] Business logic and validation rules

### 2. Identify Test Scenarios

For each public method, identify:

**Happy Path Tests**
- Normal input ‚Üí expected output
- Successful operations
- Valid state transitions

**Edge Cases**
- Empty inputs
- Boundary values (min/max)
- Nil/optional handling
- Empty collections
- Very large inputs

**Error Cases**
- Invalid input validation
- Network failures
- API errors
- Permission denied
- Timeouts
- Missing dependencies

**Async/Concurrency**
- Async method completion
- Task cancellation
- Race conditions
- Main actor operations

**State Management**
- Property updates
- Observable state changes
- State persistence
- State reset/cleanup

### 3. Generate Test Structure

Follow this template:

```swift
//
//  <ClassName>Tests.swift
//  StoneLiftingTests
//
//  Generated by Claude Code Test Generator
//

import XCTest
@testable import StoneLifting

// MARK: - Test Class

@MainActor
final class <ClassName>Tests: XCTestCase {
    // MARK: - Properties

    var sut: <ClassName>!
    var mockDependency: Mock<Dependency>!

    // MARK: - Setup & Teardown

    override func setUp() async throws {
        try await super.setUp()

        // Create mocks
        mockDependency = Mock<Dependency>()

        // Initialize system under test
        sut = <ClassName>(dependency: mockDependency)
    }

    override func tearDown() async throws {
        // Clean up
        sut = nil
        mockDependency = nil

        try await super.tearDown()
    }

    // MARK: - Tests for <MethodName>

    func test_methodName_happyPath_returnsExpectedResult() async throws {
        // Arrange
        let expectedValue = "expected"
        mockDependency.setReturnValue(expectedValue)

        // Act
        let result = await sut.methodName(input: "test")

        // Assert
        XCTAssertEqual(result, expectedValue)
        XCTAssertTrue(mockDependency.methodWasCalled)
    }

    func test_methodName_withInvalidInput_throwsError() async {
        // Arrange
        let invalidInput = ""

        // Act & Assert
        do {
            _ = await sut.methodName(input: invalidInput)
            XCTFail("Expected error to be thrown")
        } catch {
            XCTAssertTrue(error is ValidationError)
        }
    }

    func test_methodName_whenDependencyFails_handlesError() async {
        // Arrange
        mockDependency.setShouldFail(true)

        // Act
        let result = await sut.methodName(input: "test")

        // Assert
        XCTAssertNil(result)
        XCTAssertNotNil(sut.lastError)
    }
}

// MARK: - Mock Objects

final class Mock<Dependency>: Dependency {
    var methodWasCalled = false
    var capturedInput: String?
    private var returnValue: String?
    private var shouldFail = false

    func setReturnValue(_ value: String) {
        returnValue = value
    }

    func setShouldFail(_ fail: Bool) {
        shouldFail = fail
    }

    func method(input: String) async throws -> String {
        methodWasCalled = true
        capturedInput = input

        if shouldFail {
            throw MockError.failed
        }

        return returnValue ?? "default"
    }
}

enum MockError: Error {
    case failed
}
```

### 4. Test Naming Convention

Follow the pattern: `test_methodName_scenario_expectedResult`

**Examples:**
```swift
test_login_withValidCredentials_returnsUser()
test_login_withInvalidPassword_throwsAuthError()
test_login_whenNetworkFails_setsErrorState()
test_fetchStones_withEmptyResponse_returnsEmptyArray()
test_uploadImage_whenCancelled_cleansUpResources()
```

### 5. Coverage Goals

Aim for these coverage levels:
- **Critical paths** (auth, payments, data integrity): 100%
- **New features**: 80%+
- **Services**: 75%+
- **ViewModels**: 70%+
- **Overall target**: 70%+

### 6. Mocking Strategy

**What to Mock:**
- External APIs (network calls)
- Other services (dependencies)
- System services (location, camera, etc.)
- Time-dependent operations
- Random number generation

**What NOT to Mock:**
- SwiftUI framework
- Apple SDK frameworks
- The class under test
- Simple data models

**Mock Pattern:**
```swift
protocol DependencyProtocol {
    func fetchData() async throws -> Data
}

final class MockDependency: DependencyProtocol {
    var fetchDataCallCount = 0
    var fetchDataReturnValue: Data?
    var fetchDataShouldThrow = false

    func fetchData() async throws -> Data {
        fetchDataCallCount += 1

        if fetchDataShouldThrow {
            throw MockError.failed
        }

        return fetchDataReturnValue ?? Data()
    }
}
```

### 7. Async Testing Patterns

```swift
// Test async method
func test_asyncMethod_completesSuccessfully() async throws {
    let result = await sut.asyncMethod()
    XCTAssertNotNil(result)
}

// Test with timeout
func test_longRunningOperation_completesWithinTimeout() async throws {
    let task = Task {
        await sut.longRunningOperation()
    }

    try await Task.sleep(nanoseconds: 5_000_000_000) // 5 seconds
    XCTAssertTrue(task.isCancelled == false)
}

// Test main actor operations
@MainActor
func test_uiUpdate_runsOnMainThread() async {
    await sut.updateUI()
    XCTAssertTrue(Thread.isMainThread)
}

// Test cancellation
func test_operation_whenCancelled_cleansUp() async {
    let task = Task {
        await sut.operation()
    }

    task.cancel()

    // Verify cleanup happened
    XCTAssertTrue(sut.didCleanUp)
}
```

### 8. Observable/State Testing

```swift
func test_observableProperty_updatesCorrectly() async {
    // Arrange
    XCTAssertNil(sut.currentUser)

    // Act
    await sut.login(username: "test", password: "pass")

    // Assert
    XCTAssertNotNil(sut.currentUser)
    XCTAssertEqual(sut.currentUser?.username, "test")
}

func test_errorState_clearsAfterSuccessfulOperation() async {
    // Arrange - Set error state
    await sut.failedOperation()
    XCTAssertNotNil(sut.authError)

    // Act - Successful operation
    await sut.successfulOperation()

    // Assert - Error cleared
    XCTAssertNil(sut.authError)
}
```

## Output Format

```markdown
## üß™ Generated Tests for <ClassName>

**Target File**: path/to/ClassName.swift
**Test Coverage**: ~X% (estimated)
**Tests Generated**: Y test methods

---

### üìã Test Plan

**Methods to Test** (X total):
1. `methodName()` - 5 tests (happy path, edge cases, errors)
2. `anotherMethod()` - 3 tests
...

**Test Categories**:
- Unit Tests: X tests
- Integration Tests: Y tests
- Async Tests: Z tests
- Error Handling: A tests

---

### üìù Generated Test File

**File**: StoneLiftingTests/<ClassName>Tests.swift

```swift
// Full test file contents here
```

---

### üéØ Test Scenarios Covered

#### ‚úÖ Happy Paths
- [ ] Normal operations with valid input
- [ ] Successful API calls
- [ ] Valid state transitions

#### ‚ö†Ô∏è Edge Cases
- [ ] Empty/nil inputs
- [ ] Boundary values
- [ ] Large datasets

#### ‚ùå Error Cases
- [ ] Invalid input validation
- [ ] Network failures
- [ ] Permission errors
- [ ] Timeouts

#### ‚ö° Async/Concurrency
- [ ] Async method completion
- [ ] Task cancellation
- [ ] Main actor operations

#### üìä State Management
- [ ] Observable property updates
- [ ] Error state handling
- [ ] State persistence

---

### üîß Mock Objects Created

**Mocks Generated**:
1. `Mock<Dependency>` - For dependency injection
2. `MockAPIService` - For network operations
3. `MockLocationService` - For location testing

**Mock Capabilities**:
- Configurable return values
- Error simulation
- Call tracking
- Input capturing

---

### üìö Usage Instructions

**1. Add to Test Target**
- Create `StoneLiftingTests` target if it doesn't exist
- Add the generated test file
- Ensure `@testable import StoneLifting` works

**2. Run Tests**
```bash
# Run all tests
xcodebuild test -scheme StoneLifting

# Run specific test class
xcodebuild test -scheme StoneLifting -only-testing:StoneLiftingTests/<ClassName>Tests

# Run specific test method
xcodebuild test -scheme StoneLifting -only-testing:StoneLiftingTests/<ClassName>Tests/test_methodName_scenario_result
```

**3. View Coverage**
```bash
xcodebuild test -scheme StoneLifting -enableCodeCoverage YES
```

---

### üöÄ Next Steps

**Immediate**:
1. Review generated tests for accuracy
2. Add test target if missing
3. Run tests and verify they pass
4. Adjust mocks as needed

**Enhancements**:
1. Add integration tests for full workflows
2. Add UI tests for critical user flows
3. Set up CI to run tests on every commit
4. Add snapshot tests for UI components

**Customizations**:
1. Adjust mock behavior for specific scenarios
2. Add more edge case tests
3. Test error message accuracy
4. Add performance tests

---

### ‚ö†Ô∏è Important Notes

- **Review before using**: Generated tests are a starting point, review for accuracy
- **Adjust mocks**: Mock behavior may need customization based on actual dependencies
- **Add to git**: Commit tests along with implementation code
- **Maintain tests**: Update tests when implementation changes
- **Don't mock Apple frameworks**: Test against real SwiftUI/UIKit

---

### üìä Coverage Report

**Estimated Coverage**:
- Public methods: X/Y covered (Z%)
- Error paths: A/B covered (C%)
- Async operations: D/E covered (F%)

**Gaps** (needs manual test creation):
- [ ] Complex integration scenarios
- [ ] UI-specific behavior
- [ ] Performance characteristics
- [ ] Memory leak testing
```

## Special Considerations

### For Singleton Services
```swift
// Don't test singleton directly, test behavior
// Option 1: Extract protocol for dependency injection
protocol AuthServiceProtocol {
    func login() async throws
}

class AuthService: AuthServiceProtocol {
    static let shared = AuthService()
    // Implementation
}

// Option 2: Reset state between tests
override func tearDown() async throws {
    await AuthService.shared.logout()
    // Reset to clean state
}
```

### For ViewModels
```swift
// Test ViewModel separately from View
@MainActor
func test_viewModel_updatesState() async {
    let viewModel = MyViewModel()

    await viewModel.loadData()

    XCTAssertTrue(viewModel.isLoaded)
    XCTAssertFalse(viewModel.data.isEmpty)
}
```

### For Services with External Dependencies
```swift
// Use protocol-based dependency injection
protocol APIServiceProtocol {
    func request() async throws -> Data
}

class MyService {
    private let apiService: APIServiceProtocol

    init(apiService: APIServiceProtocol = APIService.shared) {
        self.apiService = apiService
    }
}

// In tests, inject mock
let mockAPI = MockAPIService()
let sut = MyService(apiService: mockAPI)
```

## Important Guidelines

1. **One test, one assertion** (or closely related assertions)
2. **Arrange-Act-Assert** structure always
3. **Descriptive test names** that explain the scenario
4. **Independent tests** - no test depends on another
5. **Fast tests** - mock slow operations
6. **Deterministic** - same input always produces same result
7. **Cleanup** - reset state in tearDown
8. **Test behavior, not implementation** - don't test private methods

## Common Patterns in This Project

### Testing Observable Services
```swift
func test_service_updatesObservableProperty() async {
    // Initial state
    XCTAssertFalse(sut.isAuthenticated)

    // Action
    await sut.login(username: "test", password: "pass")

    // Verify state changed
    XCTAssertTrue(sut.isAuthenticated)
}
```

### Testing Error Handling
```swift
func test_service_setsErrorOnFailure() async {
    // Arrange
    mockAPI.setShouldFail(true)

    // Act
    await sut.fetchData()

    // Assert
    XCTAssertNotNil(sut.lastError)
    XCTAssertTrue(sut.lastError is NetworkError)
}
```

### Testing Validation
```swift
func test_validation_withInvalidEmail_returnsFalse() {
    let result = sut.validate(email: "invalid")
    XCTAssertFalse(result.isValid)
    XCTAssertEqual(result.error, .invalidFormat)
}
```

---

**Generated tests provide a solid foundation. Always review and customize based on specific requirements.**
